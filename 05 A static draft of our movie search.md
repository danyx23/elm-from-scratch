A static draft of our movie search
==================================

Now that we have a working setup and can compile elm code into javascript, let's focus on the actual application we will develop over the course of this series.

The end result should be a little game that is modelled on a verbal game my wife and I sometimes play in long car rides. We both studied film directing and really like movies, and at some point we came up with Actor Domino (or, as we also call it "The IMDB game"). You can play it with at least 2 people and add as many players as you like. The first player names an Actress/Actor A that is the starting point. The next player now has to name another Actress or Actor B and a movie that starred those two actors. The next player now has to do the same with Actress/Actor B and a new Actor. The game is finished when you manage to come back to the initial Actor A.

Additional rules:
* Every actress/actor and every movie may only be referenced once in one game (exept the initial actor of course).
* When a player can't continue, he gets one minus point and the turn skipps to the next player. If no player can continue, the game is over and the player who mavuevered the game into the dead end is publicly shamed.
* Finishing the game by connecting back to the first actor earsn you two plus points

Ok, let's think about how that could be a computer game. A pretty straightforward translation could work like this:

* All players sit in front of the same computer
* The game begins by telling the game how many players are playing
* The first player enters the name of an actor into a search field
* To be able to verfiy if two actors played in the same movie, the game performs a XHR request to the universal movie database and searches for the actors name. This may come back with a list of potential matches.
* The player confirms the correct actor from the list
* The next player enters the name of the next actor, again choosing from a list if there are more than one match. The player also enters the title of the movie those two actors both starred in.
* The game confirms, with another search against the universal movie database, that this information is correct. If there are several movies with similar names that starr both actors, the user has to choose one.
* This continues for all players in turm, taking into account the additional rules and the game end conditions.
* The winner is the one who has the most points left

Puh, sounds like quite some complexity for such a small game. How should we tackle this? I think that a good way to go about these things is to think of some incremental steps that will get you to the final game. In this case, what is a very simple sub-problem that would already be useable on it's own? I think one thing that seems pretty obvious is entering an actors name, searching the universal movie database for that name, and presenting a list of all the matches, sorted by popularitiy. We can then add the logic to handle players and understand turns, recognizing when the game is finished, and finally checking the movie name the user enters and verifying that the two actors that are currently being matched really starred in that film.

Outline of the initial interface

Let's collect whtat we need for the intitial user interface: we need a text field to enter the name, a button to submit the search, and a list that displays the possible matches.

If we write a minimal version of this down in html, it might look like this (already showing a single search result):
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Elm movie domino</title>
  </head>
  <body>
    <input type="text"></input>
    <input type="button">Search!</input>
    <ul>
    	<li>Barbara Stanwyck</li>
    </ul>
  </body>
</html>
```

Creating DOM node in Elm

If we want to be able to create user interfaces in Elm so that the content that is displayed can change, we need to put Elm in control of all the content inside a certain tag. For now, let's just handle everything inside the body tag with Elm. If you have worked with React in Javascript before, the following will seem familiar:

We need to keep a skeletton HTML file, but with everything inside the body tag removed. Then, we need to introduce a script tag that will load the final, compiled javascript file that is generated by the elm compiler. Finally, we need another script tag to fire up elm and tell it to take over the body tag and run our program:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Elm movie domino</title>
  </head>
  <body>
  </body>

  <script src="elm-movie-domino.js"></script>
  <script>
      var app = Elm.Main.fullscreen();
  </script>
</html>
```

Ok, now let's turn to the Elm side of things. In chapter two we already saw the `text` function. We used it like this:
```Elm
import Html exposing (text, Html)

main : Html a
main =
	text "Hello from the MovieSearch app!"
```

We now need some other functions from the Html module to render different tags - in particular the input, button, ul and li tags. If you look at the documentation of each of these functions, you will see that they all have the same type signature:
```Elm
List (Attribute a) -> List (Html a) -> Html a
```
What does this mean? Each of them takes a list some type `Argument a` and a List of some `Html a` and returns a `Html a`. Since the same type variable `a` is used in the two parameters and the return type, the same concrete type will have to be used here. But we don't need to use this now and will come back to it in the next chapter when we start to make the whole thing interactive.

For now, what do the Attribute and Html types represent? They represent DOM node attributes and (child) DOM nodes respectivley (DOM is the Document Object Model, the logical structure of a website that is rendered by your browser. HTML is the textual language that can be used to serialize or write down the important part of the DOM). In our example above, we used only one attribute, the "type" attribute for the input tag, and we only had one instance where we nested a tag within another one, namely the li tag inside the ul tag. Since we have to satisfy the type signature for each function, we will have to pass two lists to each of these functions, even if they are empty - but not giving a value at all is not the same as giving an empty list for Elm!

So here is a first attempt to use these 4 functions to create a simililar DOM represenation using Elm as the original HTML draft:

```Elm
import Html exposing (text, Html, input, button, ul, li)
import Html.Attribute exposing (type)

main : Html a
main =
	input [ type text ] []
	button [] [ text "Search!" ]
	ul
		[]
		[	li [] [ text "Barbara Stanwyck" ]
		]
```

Don't compile it just yet - do you notice something? In the chapter about functions I told you that a function always has to evaluate to one expression but here we have 3 - input ..., button ..., and ul ... (Why not 4? because the li is just a function call - the result of this function will be put into a list that is the second argument to the ul function call. The ul function call is thus one expression).

You may think back to let...in, but if this is the structure we want, what would let ... in help us? The problem is that we have 3 dom nodes we want to return, but main can't be a `List (Html a)` - it can only be a `Html a` (or two other things as we saw previously).

The answer is to wrap the entire thing in one DOM node, e.g. a `div`, so that we can return a singular node from main. Does this mean that you really have to have a singular top level node in Elm? Yes indeed. In the functions you define yourself we will shortly see that it is perfectly alright to return a `List (Html a)`, but the main entry point needs a single DOM node, period. So let's do this. What is the type signature of div? Interestingly, the same as that of input, button, ul and li - in fact, practially all functions in the Html namespace have this signature (text being one of the only counter examples):

```Elm
import Html exposing (text, Html, input, button, ul, li, div)
import Html.Attribute exposing (type)

main : Html a
main =
	div []
		[	input [ type text ] []
		,	button [] [ text "Search!" ]
		,	ul
				[]
				[	li [] [ text "Barbara Stanwyck" ]
				]
		]
```

The many square brackets may confuse you a little, but just keep in mind that most of these functions (all except text), want two arguments: the list of attributes and the list of child elements. Now we have satisfied the Elm compiler - our types check out and, if we comile this with `elm make Main.elm --output elm-movie-domino.js` we should see a (ugly) little user interface if we open the html file - but this time, the content of body is rendered by evaluating our Elm code. In the next chapter, we'll introduce some interactivity, but there are two things we should look at before that - first, how to extract some of the code we wrote here into another function to make it easier to read, and second how we could model the data we need for this as a type and then construct a value of this type and pass that to our function to render the output based on some data. This second part will be a great preparation for when we add interactivity in the next chapter and actually want to change some data and see the visual representation be updated "automatically".

First, it may make sense to extract the list of results into a function. We basically want to take the ul ... part out and replace it by calling a function we write. Like so:

```Elm
resultList : Html a
resultList =
	ul
		[]
		[	li [] [ text "Barbara Stanwyck" ]
		]


main : Html a
main =
	div []
		[	input [ type text ] []
		,	button [] [ text "Search!" ]
		,	resultList
		]
```

That was easy! Ok, how about modelling the data? Well, we will want a `List String` for the actor names. We will then change resultList from a function that takes no arguments to one that takes a `List String`:


```Elm
testData : List String
testData =
	[ "Barbara Stanwyck" ]

resultList : List String -> Html a
resultList actors =
	ul
		[]
		[	li [] [ text ?? ]
		]


main : Html a
main =
	div []
		[	input [ type text ] []
		,	button [] [ text "Search!" ]
		,	resultList testData
		]
```

The basic mechanism is all in place - at the top we declare a new value testData of type `List String`. For now, it only contains one Actress. The function `resultList` now takes one argument, also a `List String`, but I left out the implementation for now and inserted some question marks. Finally, in main, we call resultList now with one argument, the testData value we defined above.

So how could we implement resultList so that it runs a `List String` into a single ul element that in turn contains, for each string element in the actors argument, one li element with the name of that actor as a html element produced by the `text` function?

The answer lies in the `map` function of the List module. It's type signature is:
```Elm
map : (a -> b) -> List a -> List b
```

What does that tell us? `map` takes two arguments. The first is a function (the parenthesis in the type signature make that clear!) that takes a value of type a and returns a value of type b - i.e. it transforms or projects a value of some type to another (a and b could also take the same concrete type). The second argument is a list of that same type a that can be the input to the function that is passed in the first parameter. Finally, the return type is a List of b, where that b is what the first argument evaluates to.

This is how you use map to turn a `List Int` into a `List String`:
```Elm
map toString [1, 2, 3]
-- the result would be ["1", "2", "3"]
```

This is just what we need in our example above. We have a List of String and we want to turn it into a List of Html. Like so:
```Elm
listEntry : String -> Html a
listEntry name =
	li [] [ text name ]

resultList : List String -> Html a
resultList actors =
	ul
		[]
		( List.map listEntry actors )
```

So for the second parameter to the function ul we now use the result of calling List.map with the list of actors names and the function listEntry that turns a single string into a single Html a element (by creating a li element containing the name as text). The function call is wrapped in parenthesis so that Elm correctly parses the function call as one group that should be evaluated and then used as the second parameter in the call to ul.

Great Success so far! We don't have any interactivity yet, but we have used functions from the Html module to mirror a html structure we had previously designed. If you need to this for some larger chunk of HTML, a great tool to use is the Html -> Elm converter. You paste in some well formed Html and it gives you back the Elm code to generate the equvalent DOM nodes via Elm.

In the next chapter we will start using interactivity and use a more complex model than just a List of Strings.
